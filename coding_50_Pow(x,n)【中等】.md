[toc]

### 题目描述

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

- 示例 1:
```
输入: 2.00000, 10
输出: 1024.00000
```
- 示例 2:
```
输入: 2.10000, 3
输出: 9.26100
```
- 示例 3:
```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```
- 说明:
```
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
```

### 题目分析

#### 暴力法解析

循环相乘就ok了，时间复杂度O(n),但是如果用快速幂算法的话时间复杂度为O(logn)

### 快速幂算法

在做这道题之前呢，我们先了解一下什么是快速幂算法?

#### 实例

我们先来看一道题目，然后一步一步分析

求`A^B`的最后三位数表示的整数<br/>
说明：`A^B`的含义是"A的B次方"

#### 简单解法

这道题目乍一看会觉得并不难啊，题目短短一行而已，而且思路也很容易，求幂这种算法一般在初学程序设计语言的时候应该都有联系过，只要写一个简单的循环就能够搞定。

```java
public long normalPower(long base, long power) {
    long result = 1;
    for (int i = 1; i <= power; i++) {
        result = result * base;
    }
    return result % 1000;
}
```
然后，让我们愉快的来求一下2^100的结果的后三位数表示的整数是什么吧
<font size = 3 color = red>什么答案会是0呢？明明没有错误的啊！~ </font>

先不急，我们再来考虑一下，这道题其实出的很有意思，题目要求你输出结果的后三位，为什么不让你直接输出结果呢？难道仅仅只是为了增大题目的难度吗？当然不是，我们在初中就学过“指数爆炸”，下面我们在来回顾一下“指数”的概念：

指数：在乘方a中，其中的a叫做底数，n叫做指数，结果叫幂。

f(x)=a^x ， 随着x单位长度的递增，f(x)会呈“爆炸性”增长。

一张纸对折一次，厚度变成原来的2倍。再对折第二次，变为原来的2的2次方倍即4倍。以此类推，假设纸的厚度为0.1mm，则对折24次以后，长度超过1千米；对折39次达55000千米，超过地球赤道长度；对折42次达44万千米，超过地球至月球的距离；对折51次达22亿千米，超过地球至太阳的距离；对折82次为51113光年，超过银河系半径的长度。

因此，如果题目让你求2的100次方，貌似我们程序设计语言中最大的long类型也无法承载这么大的数值，所以题目才不会要求你输出结果，因为结果可能会非常的大，大到没有任何类型可以承载。所以我们会发现上面的结果为什么是0，因为已经发生溢出了。

那为什么题目要求输出结果的最后三位数表示的整数呢？有的同学可能会问：求一个数的最后三位数表示的整数好办，只要用这个结果进行“取模”运算，让其对1000取模，得到的数就是这个数最后三位数表示的整数。（例如：12345的最后三位数表示的整数是：12345%1000=345）。但是，你这结果都无法求出来，让我怎么进行“取模”运算呢？你这不是瞎闹吗？

别急，我们首先来了解一下“取模”运算的运算法则：
```
(a + b) % p = (a % p + b % p) % p （1）

(a - b) % p = (a % p - b % p ) % p （2）

(a * b) % p = (a % p * b % p) % p （3）
```

其中我们只要关注第“3”条法则即可：`(a * b) % p = (a % p * b % p) % p` ，我们仔细研究一下这个运算法则，会发现多个因子连续的乘积取模的结果等于每个因子取模后的乘积再取模的结果。也就是说，我们如果要求：

`( a * b * c ) % d=( a % d * b % d * c % d ) % d;`

因此，我们可以借助这个法则，只需要在循环乘积的每一步都提前进行“取模”运算，而不是等到最后直接对结果“取模”，也能达到同样的效果。

所以，我们的代码可以变成这个样子：

```java
public long normalPower(long base, long power) {
    long result = 1;
    for (int i = 1; i <= power; i++) {
        result = result * base;
        result = result%1000;
    }
    return result % 1000;
}
```

到这里，我们的简单算法就已经完成了，已经可以AC这道题了，接下来我们讨论的就是时间复杂度的问题了

#### 快速幂算法入门

我们将上面的代码求`2^10000000000`次方，这个程序会运行很久才能完成，那么有没有什么好的办法能够对其进行优化呢？

快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。让我们先来看一个简单的例子：

`3^10=3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3 * 3`

- 尽量想办法把指数变小来，这里的指数为10<br/>
`3^10=(3*3)*(3*3)*(3*3)*(3*3)*(3*3)`<br/>
`3^10=(3*3)^5`<br/>
`3^10=9^5`<br/>
- 此时指数由10缩减一半变成了5，而底数变成了原来的平方，求`3^10`原本需要执行10次循环操作，求`9^5`却只需要执行5次循环操作，但是`3^10`却等于`9^5`,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如`2^10000=4^5000`,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。
- 现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5<br/>
`9^5=（9^4）*（9^1）`
- 此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作<br/>
`9^5=（81^2）*(9^1)`
- 把指数缩小一半，底数执行平方操作<br/>
`9^5=（6561^1）*(9^1)`
- 此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。<br/>
`9^5=（6561^0）*(9^1)*(6561^1)=1*(9^1)*(6561^1)=(9^1)*(6561^1)=9*6561=59049`
- 我们能够发现，最后的结果是9*6561，而9是怎么产生的？是不是当指数为奇数5时，此时底数为9。那6561又是怎么产生的呢？是不是当指数为奇数1时，此时的底数为6561。所以我们能发现一个规律：<font size = 3 color = red>最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。</font>

#### 代码来演示快速幂算法

```java
/**
 * 快速幂算法
 */
public static double myPow(double x, int n) {
    long pow = n;
    double res = 1;
    if (pow < 0) {
        x = 1 / x;
        pow = - pow;
    }
    while (pow > 0) {
        if (pow % 2 == 0) {
            //如果指数为偶数
            pow = pow / 2; //把指数缩小为一半
            x = x * x % 1000; //底数变大成原来的平方
        } else {
            //如果指数为奇数
            pow = pow - 1; //把指数减去1，使其变成一个偶数
            res = res * x % 1000;//此时记得要把指数为奇数时分离出来的底数的一次方收集好
            pow = pow / 2;//此时指数为偶数，可以继续执行操作
            x = x * x % 1000;
        }
    }
    return res;
}
```
#### 优化

- 抽出if-else中公共的部分
```java
pow = pow / 2;
x = x * x % 1000;
```
- 判断是否是偶数的方法
```
if( (pow & 1)==1){//是奇数，否则偶数
    
}
```
- 因为pow是一个整数，例如当pow是奇数5时,pow-1=4,pow/2=2；而如果我们直接用pow/2=5/2=2。在整型运算中得到的结果是一样的

```
去掉pow = pow - 1; 
```
- 位运算
```
pow = pow >>> 1;
```

```
public static double myPow(double x, int n) {
    long pow = n;
    double res = 1;
    if (pow < 0) {
        x = 1 / x;
        pow = - pow;
    }
    while (pow > 0) {
        if( (pow & 1) == 1 ){
            res = res * x % 1000;
        }
        pow = pow >>> 1;
        x = x * x % 1000;
    }
    return res;
}
```






