[toc]

### 题目描述(中等)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组`[0,1,2,4,5,6,7]`可能变为`[4,5,6,7,0,1,2]`)。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回`-1`。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是`O(log n)` 级别。

- 示例 1:
```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```
- 示例 2:
```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

### 题目分析

1. 一般像这种在`有序数组`中寻找某个目标值的算法可用`二分搜索算法`来解
2. 况且题目中说了`你的算法时间复杂度必须是 O(log n) 级别。`这就在暗示我们使用二分搜索算法
3. 本题中的数组不同一般的数组,是`旋转数组`
4. `旋转数组`: 升序排序的数组在预先未知的某个点上进行了旋转(例: `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]`有点滚动的意思,数组前面的元素向后移动从而空出了数组前面的位置,而数组后面的元素因为前面的元素来了被挤掉了,所以将被挤掉的元素又移到前面空出来的位置)
5. 由上面的数组旋转的例子可以清晰的看到数组被分成了有序的两段,`[4,5,6,7,0,1,2]`数组中`[4,5,6,7]`和`[0,1,2]`两段是有序的,所以我们接下来的讨论是在这两段关系中讨论的,左边的部分我们叫它左半段,右边的称为右半段
6. 在旋转数组中,`mid`有可能落在左半段也有可能落在右半段,`target`我们需要看它落在`mid`的左边还是右边,所以我们先要分清`mid`和`target`分别落在哪个段`(如: [4,5,6,7(mid),8,1,2,3] 7所在位置是初始mid的位置,mid位于左半段;如: [5,6,7,1(mid),2,3,4] 1所在位置是初始mid的位置,mid位于右半段)`
7. 首选判断`mid`落在哪个段,`if(num[mid]>num[left])说明mid落在左半段否则落在右半段`
8. 再判断`target`落在`mid`的左边还是右边
9. 我们知道二分搜索算法的关键点在于`num[mid]`的值和`target`的值的大小关系
10. 如果`mid`落在左半段,且`num[left]<= target < num[mid]` 那么这个时候就需要在 `[left,mid-1]`区间中进行二分搜索,因为这个区间是有序的;<br/>如果`mid`落在左半段,并且 `num[mid] < target <= num[right] ` 那么这个时候就需要在 `[mid+1,right]`区间内再判断新的`mid`落在哪个区间,整体流程如下图所示![image](http://tie.027cgb.com/606599/LeetCoding/2.png)
11. `mid`落在左半段同理推理

### 题目解法

#### '排除法'二分搜索算法解本题

```java
public static int search(int[] nums, int target) {
        int len = nums.length;
        if (len == 0) return -1;
        int left = 0;
        int right = len - 1;
        /**
         * 旋转数组: 将数组分成了两个有序区间(这里我们叫它左区间和右区间) 例: [4,5,6,7,8,1,2,3]
         * 其中mid的位置也会有所不同
         * 1.mid落在左区间
         *   如: [4,5,6,7(mid),8,1,2,3] 7所在位置是初始mid的位置
         *   如果mid落在左区间,并且 target < num[mid] 那么这个时候就需要在 [left,mid-1]区间中进行二分搜索
         *   如果mid落在左区间,并且 target > num[mid] 那么这个时候就需要在 [mid+1,right]区间内再判断新的mid落在哪个区间,进而判断新的区间中target落在哪个区间
         * 2.mid落在右区间
         *   如: [5,6,7,1(mid),2,3,4] 1所在位置是初始mid的位置
         *   如果mid落在右区间,并且 target > num[mid] 那么这个时候就需要在 [mid+1,right]区间进行二分搜索
         *   如果mid落在右区间,并且 target < num[mid] 那么这个时候就需要在 [left,mid-1]区间中再判断新的mid落在哪个区间,进而判断新的区间中target落在哪个区间
         */
        while (left < right) {
            //int mid = (left + right) >>> 1;
            int mid = left + ((right - left) >>> 1);
            if(nums[mid] == target){
                return mid;
            }
            //首先看mid落在哪个区间
            //mid落在左区间
            if(nums[mid] >= nums[left]){
                if(target < nums[mid] && target >= nums[left]){
                    right = mid - 1;
                }else {
                    left = mid + 1;
                }
            //mid落在右区间
            }else {
                if(target > nums[mid] && target <= nums[right]){
                    left = mid + 1;
                }else {
                    right = mid - 1;
                }
            }
        }
        if(nums[left] != target){
            left = -1;
        }
        return left;
    }
```

